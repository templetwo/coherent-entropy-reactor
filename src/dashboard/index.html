<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CER | The Temple Instrument v3.0</title>
    <link
        href="https://fonts.googleapis.com/css2?family=Cinzel:wght@400;700&family=Lora:ital,wght@0,400;0,700;1,400&family=JetBrains+Mono:wght@300;500&display=swap"
        rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
    <style>
        :root {
            --bg-color: #000000;
            --card-bg: rgba(10, 10, 10, 0.85);
            --text-gold: #d4af37;
            --accent-gold: #ffcc00;
            --border-gold: rgba(212, 175, 55, 0.3);
            --glow: 0 0 20px rgba(212, 175, 55, 0.15);
            --status-stable: #10b981;
            --status-exploring: #38bdf8;
            --status-chimera: #9370DB;
            --status-collapsed: #f43f5e;
        }

        body {
            font-family: 'Lora', serif;
            background-color: var(--bg-color);
            color: var(--text-gold);
            margin: 0;
            padding: 0;
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
            /* Main UI is fixed-layer */
        }

        #observatory-viewport {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 1;
            cursor: grab;
        }

        #observatory-viewport:active {
            cursor: grabbing;
        }

        .ui-layer {
            position: fixed;
            z-index: 10;
            width: 100%;
            height: 100vh;
            display: grid;
            grid-template-columns: 300px 1fr 300px;
            grid-template-rows: auto 1fr auto;
            gap: 15px;
            padding: 20px;
            box-sizing: border-box;
            pointer-events: none;
            /* Keep off by default */
        }

        .ui-element {
            pointer-events: auto;
            /* Enable only on UI cards */
            background: var(--card-bg);
            backdrop-filter: blur(10px);
        }

        /* Header spans full width */
        .header {
            grid-column: 1 / -1;
            grid-row: 1;
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding-bottom: 15px;
            border-bottom: 1px solid var(--border-gold);
            pointer-events: auto;
        }


        .controls {
            display: flex;
            gap: 10px;
            align-items: center;
            pointer-events: auto;
        }

        button,
        select {
            background: rgba(0, 0, 0, 0.6);
            color: var(--text-gold);
            border: 1px solid var(--border-gold);
            padding: 6px 15px;
            font-family: 'Cinzel', serif;
            font-size: 0.75rem;
            letter-spacing: 0.1em;
            cursor: pointer;
            transition: all 0.3s;
            backdrop-filter: blur(5px);
        }

        button:hover,
        select:hover {
            border-color: var(--accent-gold);
            box-shadow: 0 0 10px var(--accent-gold);
        }

        button.active {
            background: var(--accent-gold);
            color: black;
        }

        .stats-overlay {
            display: grid;
            grid-template-columns: repeat(4, 1fr);
            gap: 15px;
            width: 100%;
            margin-top: 15px;
        }

        .stat-card {
            background: var(--card-bg);
            border: 1px solid var(--border-gold);
            padding: 12px;
            text-align: center;
            box-shadow: var(--glow);
        }

        .stat-label {
            font-family: 'Cinzel', serif;
            font-size: 0.6rem;
            opacity: 0.6;
            margin-bottom: 4px;
        }

        .stat-value {
            font-family: 'JetBrains Mono', monospace;
            font-size: 1.4rem;
            color: var(--accent-gold);
        }

        .stat-meta {
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.6rem;
            opacity: 0.4;
        }

        .bottom-ui {
            margin-top: auto;
            display: flex;
            justify-content: space-between;
            align-items: flex-end;
            width: 100%;
        }

        .analysis-tool {
            width: 300px;
            background: var(--card-bg);
            border: 1px solid var(--border-gold);
            padding: 10px;
        }

        .status-panel {
            text-align: center;
            padding: 15px;
            background: var(--card-bg);
            border: 1px solid var(--border-gold);
        }

        .status-badge {
            font-family: 'Cinzel', serif;
            font-size: 0.8rem;
            letter-spacing: 0.3em;
            padding: 8px 30px;
            border: 1px solid;
            margin-bottom: 5px;
            display: inline-block;
        }

        .status-STABLE {
            color: var(--status-stable);
            border-color: var(--status-stable);
            box-shadow: 0 0 20px rgba(16, 185, 129, 0.3);
        }

        .status-EXPLORING {
            color: var(--status-exploring);
            border-color: var(--status-exploring);
            box-shadow: 0 0 20px rgba(56, 189, 248, 0.3);
        }

        .status-CHIMERA {
            color: var(--status-chimera);
            border-color: var(--status-chimera);
            box-shadow: 0 0 20px rgba(147, 112, 219, 0.3);
        }

        .status-COLLAPSED {
            color: var(--status-collapsed);
            border-color: var(--status-collapsed);
            box-shadow: 0 0 20px rgba(244, 63, 94, 0.3);
        }

        .ritual-footer {
            opacity: 0.4;
            font-family: 'Cinzel', serif;
            font-size: 0.6rem;
            letter-spacing: 0.4em;
        }

        /* Oracle Pulse Stream Styling */
        #oracle-stream {
            display: flex;
            flex-wrap: wrap;
            align-content: flex-start;
            overflow-y: auto !important;
            scrollbar-width: none;
            padding: 15px;
            gap: 8px;
        }

        #oracle-stream::-webkit-scrollbar {
            display: none;
        }

        .oracle-glyph {
            display: inline-block;
            font-family: 'Cinzel', serif;
            transition: all 0.5s ease;
            text-shadow: 0 0 10px currentColor;
            animation: glyph-entry 0.3s ease-out;
        }

        @keyframes glyph-entry {
            from {
                transform: scale(0);
                opacity: 0;
            }

            to {
                transform: scale(1);
                opacity: 1;
            }
        }

        /* Event Log Styling */
        #event-log {
            font-family: 'Courier New', monospace;
            font-size: 0.7rem;
            color: var(--text-gold);
            overflow-y: auto;
            height: 150px;
            border-top: 1px solid var(--border-gold);
            padding-top: 10px;
            margin-top: 10px;
            display: flex;
            flex-direction: column-reverse;
            /* Newest at bottom visually, or fix scroll */
        }

        .log-entry {
            margin-bottom: 4px;
            opacity: 0.8;
        }

        .log-timestamp {
            color: #666;
            margin-right: 8px;
        }

        .log-type-state {
            color: var(--accent-gold);
        }

        .log-type-alert {
            color: var(--status-collapsed);
        }

        .log-type-info {
            color: var(--status-stable);
        }
    </style>
</head>

<body>
    <div id="observatory-viewport"></div>

    <div class="ui-layer">
        <div class="header ui-element">
            <h1>TEMPLE OBSERVATORY v3.1 // <span style="font-weight: 300;">3D FIELD Tomography</span></h1>
            <div class="controls">
                <button id="audioToggle">üîä LISTEN</button>
                <select id="audioMode">
                    <option value="resonance">Resonance</option>
                    <option value="continuous">Continuous</option>
                    <option value="binaural">Binaural</option>
                </select>
                <button id="startBtn">Commence</button>
                <button id="oracleBtn">ORACLE</button>
                <button id="recordBtn">Record</button>
                <button id="markBtn">Mark</button>
                <button id="exportBtn" title="Export trajectory data as CSV">üìä Export</button>
                <button id="resetBtn">Purge</button>
            </div>
        </div>

        <div class="stats-overlay ui-element">
            <div class="stat-card">
                <div class="stat-label">Entropy Flux</div>
                <div id="entropy-val" class="stat-value">0.00</div>
                <div id="entropy-delta" class="stat-meta">--</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">Semantic Mass</div>
                <div id="mass-val" class="stat-value">0.0000</div>
                <div id="mass-delta" class="stat-meta">--</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">Phase Coherence</div>
                <div id="phase-val" class="stat-value">0.000</div>
                <div id="phase-delta" class="stat-meta">--</div>
            </div>
            <div class="stat-card">
                <div class="stat-label">Attractor Stability</div>
                <div id="stability-val" class="stat-value">0.000</div>
                <div id="stability-delta" class="stat-meta">--</div>
            </div>
        </div>

        <!-- Oracle Stream & Analysis Layer -->
        <div style="display: flex; gap: 20px; margin-top: 15px; flex: 1; overflow: hidden;">
            <div class="stat-card ui-element" style="flex: 2; display: flex; flex-direction: column; text-align: left;">
                <div class="stat-label">Oracle Pulse Stream // REAL-TIME METRIC STREAM</div>
                <div id="oracle-stream"
                    style="flex: 1; font-family: 'Cinzel', serif; font-size: 2.5rem; overflow: hidden; display: flex; align-items: center; justify-content: center; gap: 10px;">
                    <!-- Pulse tokens will appear here -->
                </div>
            </div>
            <div class="stat-card ui-element" style="flex: 1; display: flex; flex-direction: column;">
                <div class="stat-label">Pattern Analysis</div>
                <div style="text-align: left; padding: 10px; flex: 1;">
                    <div id="analysis-periodicity" style="margin-bottom: 8px; font-size: 0.7rem;">Periodicity: <span
                            style="color: grey;">---</span></div>
                    <div id="analysis-confinement" style="margin-bottom: 8px; font-size: 0.7rem;">Confinement: <span
                            style="color: grey;">---</span></div>
                    <div id="analysis-surprise" style="margin-bottom: 8px; font-size: 0.7rem;">Surprise: <span
                            style="color: grey;">---</span></div>
                    <div id="analysis-verdict"
                        style="margin-top: 10px; font-family: 'Cinzel', serif; font-size: 0.7rem; color: var(--accent-gold); height: 20px;">
                        Observing Field Resonance...</div>
                </div>

                <div class="stat-label" style="border-top: 1px solid #333; padding-top: 5px; margin-top: 5px;">Field Log
                </div>
                <div id="event-log">
                    <!-- Logs appear here -->
                </div>
            </div>
        </div>

        <div class="bottom-ui">
            <div class="analysis-tool ui-element">
                <div class="stat-label" style="margin-bottom: 10px;">Field Parameters</div>
                <label class="stat-label">Temperature: <span id="temp-val">1.0</span></label>
                <input type="range" id="tempSlider" min="0.1" max="2.0" step="0.05" value="1.0"
                    style="width: 100%; margin-bottom: 15px;">
                <label class="stat-label">Presets</label>
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 5px;">
                    <button onclick="applyPreset('stable')">STABLE</button>
                    <button onclick="applyPreset('creative')">CREATIVE</button>
                    <button onclick="applyPreset('chimera')">CHIMERA</button>
                    <button onclick="applyPreset('void')">VOID</button>
                </div>
            </div>

            <div class="status-panel ui-element">
                <div id="status-badge" class="status-badge status-EXPLORING">EXPLORING</div>
                <div class="ritual-footer">üúè FIELD OBSERVATION IN PROGRESS üúè</div>
            </div>
        </div>
    </div>

    <script>
        // --- 3D Observatory Core (Three.js) ---
        let scene, camera, renderer, merkabah, trajectoryGroup, controls;
        let points = [];
        let maxPoints = 500;
        let is3DAutoRotate = true;

        function init3D() {
            scene = new THREE.Scene();
            scene.fog = new THREE.FogExp2(0x000000, 0.001);

            camera = new THREE.PerspectiveCamera(60, window.innerWidth / window.innerHeight, 0.1, 2000);
            camera.position.set(150, 100, 150);
            camera.lookAt(0, 0, 0);

            renderer = new THREE.WebGLRenderer({ antialias: true, alpha: true });
            renderer.setSize(window.innerWidth, window.innerHeight);
            renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
            renderer.toneMapping = THREE.ACESFilmicToneMapping;
            renderer.toneMappingExposure = 1.2;
            document.getElementById('observatory-viewport').appendChild(renderer.domElement);

            // Enhanced Lighting for PBR
            const hemiLight = new THREE.HemisphereLight(0xd4af37, 0x1a1a1a, 0.6);
            scene.add(hemiLight);

            const spotLight1 = new THREE.SpotLight(0xffcc00, 2, 600, Math.PI / 6, 0.5, 1);
            spotLight1.position.set(150, 200, 150);
            spotLight1.castShadow = false;  // Disable shadows for performance
            scene.add(spotLight1);

            const spotLight2 = new THREE.SpotLight(0x8888ff, 1, 400, Math.PI / 8, 0.3, 1);
            spotLight2.position.set(-100, 150, -100);
            scene.add(spotLight2);

            // Merkabah (Sacred Geometry) - PBR Materials
            merkabah = new THREE.Group();

            // Wireframe with STRONG emissive glow
            const wireMat = new THREE.MeshStandardMaterial({
                color: 0xffdd44,  // Brighter gold
                emissive: 0xffcc00,
                emissiveIntensity: 1.2,  // BOOSTED from 0.4
                wireframe: true,
                transparent: true,
                opacity: 0.95,  // BOOSTED from 0.6
                metalness: 0.9,
                roughness: 0.1
            });

            // Solid core with glass-like material (BRIGHTER)
            const glassMat = new THREE.MeshPhysicalMaterial({
                color: 0xffdd44,
                emissive: 0xffcc00,
                emissiveIntensity: 0.4,
                metalness: 0.1,
                roughness: 0.05,
                transparent: true,
                opacity: 0.5,  // BOOSTED from 0.15
                transmission: 0.6,
                ior: 1.5
            });

            const tetraGeo = new THREE.TetrahedronGeometry(40, 0);

            // Two counter-rotating tetrahedrons (BOTH VISIBLE)
            const t1 = new THREE.Mesh(tetraGeo, wireMat);
            const t2 = new THREE.Mesh(tetraGeo.clone(), wireMat.clone());
            t2.rotation.y = Math.PI;
            t2.rotation.z = Math.PI;
            t2.scale.set(1.08, 1.08, 1.08);  // Slightly larger so both are visible

            // Glass core (BRIGHTER + LARGER)
            const core = new THREE.Mesh(new THREE.SphereGeometry(20, 32, 32), glassMat);

            merkabah.add(t1, t2, core);
            scene.add(merkabah);

            // Trajectory Particle System
            trajectoryGroup = new THREE.Group();
            scene.add(trajectoryGroup);

            // Grid Floor with gradient
            const grid = new THREE.GridHelper(400, 20, 0x444444, 0x222222);
            grid.position.y = -50;
            grid.material.opacity = 0.4;
            grid.material.transparent = true;
            scene.add(grid);

            // OrbitControls with Bounds
            try {
                if (typeof THREE.OrbitControls !== 'undefined') {
                    controls = new THREE.OrbitControls(camera, renderer.domElement);
                    controls.enableDamping = true;
                    controls.dampingFactor = 0.05;
                    controls.minDistance = 50;
                    controls.maxDistance = 500;
                    controls.autoRotate = false;
                    controls.enablePan = true;
                    controls.panSpeed = 0.5;
                    controls.rotateSpeed = 0.8;

                    controls.addEventListener('start', () => {
                        is3DAutoRotate = false;
                    });
                } else {
                    console.warn("OrbitControls not loaded. Falling back to auto-rotation.");
                }
            } catch (e) {
                console.error("OrbitControls init failed:", e);
            }

            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }

        function addTrajectoryPoint(x, y, z, coherence) {
            // Scale metrics for 3D space
            const px = (x - 4.5) * 100;
            const py = (y - 0.95) * 500;
            const pz = (coherence - 0.5) * 100;

            // Create glowing particle
            const pointGeo = new THREE.SphereGeometry(2, 16, 16);
            const pointMat = new THREE.MeshStandardMaterial({
                color: 0xffcc00,
                emissive: 0xffcc00,
                emissiveIntensity: 1.0,
                metalness: 0.3,
                roughness: 0.4,
                transparent: true
            });
            const pointMesh = new THREE.Mesh(pointGeo, pointMat);
            pointMesh.position.set(px, py, pz);

            // Add glow sphere
            const glowGeo = new THREE.SphereGeometry(3, 8, 8);
            const glowMat = new THREE.MeshBasicMaterial({
                color: 0xffcc00,
                transparent: true,
                opacity: 0.2,
                blending: THREE.AdditiveBlending
            });
            const glow = new THREE.Mesh(glowGeo, glowMat);
            pointMesh.add(glow);

            trajectoryGroup.add(pointMesh);
            points.push(pointMesh);

            if (points.length > maxPoints) {
                const old = points.shift();
                trajectoryGroup.remove(old);
                old.geometry.dispose();
                old.material.dispose();
                if (old.children.length > 0) {
                    old.children[0].geometry.dispose();
                    old.children[0].material.dispose();
                }
            }

            // Fade and color-shift based on age and metrics
            points.forEach((p, idx) => {
                const ratio = idx / points.length;
                const age = 1.0 - ratio;

                // Entropy -> Hue (blue=low, yellow=mid, red=high)
                const hue = Math.min(0.15, Math.max(0, (x - 3.0) / 4.0 * 0.15));

                p.material.opacity = ratio * 0.9;
                p.material.emissiveIntensity = ratio * 1.5;
                p.scale.set(ratio * 1.2, ratio * 1.2, ratio * 1.2);
                p.material.color.setHSL(hue, 0.8, 0.5);
                p.material.emissive.setHSL(hue, 0.8, 0.5);

                if (p.children.length > 0) {
                    p.children[0].material.opacity = ratio * 0.3;
                }
            });
        }

        function animate3D() {
            requestAnimationFrame(animate3D);

            if (merkabah) {
                // Adaptive rotation speed based on stability
                const rotSpeed = 0.001 + (currentMetrics.stability || 0) * 0.015;
                merkabah.rotation.y += rotSpeed;
                merkabah.rotation.z += rotSpeed * 0.3;

                // Pulse emissive intensity
                const pulse = Math.sin(Date.now() * 0.001) * 0.5 + 0.5;
                merkabah.children.forEach((child, idx) => {
                    if (idx < 2) {  // Wireframe tetrahedrons
                        child.material.opacity = 0.4 + (currentMetrics.stability || 0) * 0.3;
                        child.material.emissiveIntensity = 0.3 + pulse * 0.2;
                    } else {  // Glass core
                        child.material.opacity = 0.1 + (currentMetrics.phase_coherence || 0) * 0.2;
                    }
                });
            }

            // Auto-rotate camera (if not manually controlled)
            if (is3DAutoRotate && !controls?.autoRotate) {
                const time = Date.now() * 0.00008;
                const radius = 200;
                camera.position.x = Math.cos(time) * radius;
                camera.position.z = Math.sin(time) * radius;
                camera.position.y = 100 + Math.sin(time * 0.5) * 20;
                camera.lookAt(0, 0, 0);
            }

            if (controls) controls.update();
            renderer.render(scene, camera);
        }

        // --- Core Dynamics & Stats ---
        const ws = new WebSocket(`ws://${window.location.host}/ws`);
        let currentMetrics = { entropy: 4.5, mass: 0.95, phase_coherence: 0.1, stability: 0.5 };
        let history = { entropy: [], mass: [], phase: [] };
        let lastState = "UNKNOWN";

        ws.onmessage = (event) => {
            const data = JSON.parse(event.data);
            if (data.type === 'reset') { location.reload(); return; }

            // Update stats window
            history.entropy.push(data.entropy);
            history.mass.push(data.mass);
            history.phase.push(data.phase_coherence);
            if (history.entropy.length > 50) {
                history.entropy.shift(); history.mass.shift(); history.phase.shift();
            }

            // Calculate Stability & Chimera
            const meanMass = history.mass.reduce((a, b) => a + b, 0) / history.mass.length;
            const entVar = history.entropy.length > 1 ? variance(history.entropy) : 0;
            const phaseStd = history.phase.length > 1 ? std(history.phase) : 0.01;

            const stability = (meanMass * (1 - Math.min(0.9, entVar))) / (1 + phaseStd);
            currentMetrics = { ...data, stability };

            // Chimera Detection
            // If both order and chaos coexist (heuristically: high variance and high mean)
            const isChimera = entVar > 0.02 && meanMass > 0.98;
            const isCollapsed = data.mass < 0.96;

            updateUI(data, stability, isChimera, isCollapsed);
            addTrajectoryPoint(data.entropy, data.mass, data.phase_coherence, data.phase_coherence);

            if (data.sampled_token) {
                handleOraclePulse(data.sampled_token);
                addSamplingBurst(data.entropy, data.mass, data.phase_coherence);
                playSpark();
            }

            updateSound(currentMetrics);
            runAnalysis();
        };

        function handleOraclePulse(token) {
            const stream = document.getElementById('oracle-stream');
            const span = document.createElement('span');
            span.innerText = token;
            span.className = 'oracle-glyph';

            // Color based on stability/coherence
            const stability = currentMetrics.stability || 0.5;
            if (stability > 0.95) span.style.color = 'var(--accent-gold)';
            else if (stability < 0.90) span.style.color = 'var(--status-collapsed)';
            else span.style.color = 'var(--status-exploring)';

            // Size based on mass
            const mass = currentMetrics.mass || 0.98;
            const size = 1.5 + (mass - 0.98) * 50;
            span.style.fontSize = `${Math.max(1.2, Math.min(3, size))}rem`;

            stream.appendChild(span);
            // Auto-scroll to bottom
            stream.scrollTo({ top: stream.scrollHeight, behavior: 'smooth' });

            if (stream.children.length > 60) {
                stream.removeChild(stream.firstChild);
            }
        }

        function addSamplingBurst(x, y, z) {
            const px = (x - 4.5) * 100;
            const py = (y - 0.95) * 500;
            const pz = (z - 0.5) * 100;

            const burstGeo = new THREE.SphereGeometry(2, 12, 12);
            const burstMat = new THREE.MeshBasicMaterial({ color: 0xffffff, transparent: true, opacity: 0.9, blending: THREE.AdditiveBlending });
            const burst = new THREE.Mesh(burstGeo, burstMat);
            burst.position.set(px, py, pz);
            scene.add(burst);

            let scale = 1;
            const anim = () => {
                scale += 0.3;
                burst.scale.set(scale, scale, scale);
                burst.material.opacity -= 0.08;
                if (burst.material.opacity > 0) {
                    requestAnimationFrame(anim);
                } else {
                    scene.remove(burst);
                    burstGeo.dispose();
                    burstMat.dispose();
                }
            };
            anim();
        }

        function runAnalysis() {
            if (history.entropy.length < 20) return;

            const entRange = Math.max(...history.entropy) - Math.min(...history.entropy);
            const massStability = std(history.mass);

            const periodicity = massStability < 0.0005 ? "Resonant" : "Chaotic";
            const confinement = entRange < 0.15 ? "Core Lock" : "Expansive";
            const surprise = history.entropy[history.entropy.length - 1] > (history.entropy[history.entropy.length - 2] + 0.05);

            document.getElementById('analysis-periodicity').innerHTML = `Periodicity: <span style="color: var(--accent-gold);">${periodicity}</span>`;
            document.getElementById('analysis-confinement').innerHTML = `Confinement: <span style="color: var(--status-stable);">${confinement}</span>`;
            document.getElementById('analysis-surprise').innerHTML = `Surprise: <span style="color: ${surprise ? 'var(--status-collapsed)' : 'grey'};">${surprise ? 'HIGH' : 'Low'}</span>`;

            const v = document.getElementById('analysis-verdict');
            if (confinement === "Core Lock" && periodicity === "Resonant") v.innerText = "ORACLE SEES CLARITY";
            else if (surprise) v.innerText = "FIELD SPARK DETECTED";
            else v.innerText = "Observing Field Resonance...";
        }

        function variance(arr) {
            const mean = arr.reduce((a, b) => a + b) / arr.length;
            return arr.reduce((a, b) => a + Math.pow(b - mean, 2), 0) / arr.length;
        }
        function std(arr) { return Math.sqrt(variance(arr)); }

        function updateUI(data, stability, isChimera, isCollapsed) {
            document.getElementById('entropy-val').innerText = data.entropy.toFixed(2);
            document.getElementById('mass-val').innerText = data.mass.toFixed(4);
            document.getElementById('phase-val').innerText = data.phase_coherence.toFixed(3);
            document.getElementById('stability-val').innerText = stability.toFixed(3);

            const badge = document.getElementById('status-badge');
            let state = 'EXPLORING';
            if (isCollapsed) state = 'COLLAPSED';
            else if (isChimera) state = 'CHIMERA';
            else if (stability > 0.97) state = 'STABLE';

            badge.innerText = state;
            badge.className = `status-badge status-${state}`;

            if (state !== lastState) {
                logEvent(`Field Shift: ${state}`, 'state');
                lastState = state;
            }
        }

        // --- Audio System (Kuramoto-Style Resonance) ---
        let audioCtx, gainNode, oscillators = [], droneOsc, droneGain;
        let isListening = false;

        function initAudio() {
            if (audioCtx) return;
            audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            gainNode = audioCtx.createGain();
            gainNode.gain.value = 0;
            gainNode.connect(audioCtx.destination);

            // Sub-harmonic Resonance Drone
            droneOsc = audioCtx.createOscillator();
            droneOsc.type = 'sawtooth';
            droneOsc.frequency.value = 55; // A1
            droneGain = audioCtx.createGain();
            droneGain.gain.value = 0;

            const lpf = audioCtx.createBiquadFilter();
            lpf.type = 'lowpass';
            lpf.frequency.value = 150;

            droneOsc.connect(lpf);
            lpf.connect(droneGain);
            droneGain.connect(gainNode);
            droneOsc.start();
        }

        function playSpark() {
            if (!isListening || !audioCtx) return;
            const osc = audioCtx.createOscillator();
            const g = audioCtx.createGain();
            osc.frequency.setValueAtTime(600 + Math.random() * 200, audioCtx.currentTime);
            g.gain.setValueAtTime(0.2, audioCtx.currentTime);
            g.gain.exponentialRampToValueAtTime(0.01, audioCtx.currentTime + 0.05);
            osc.connect(g);
            g.connect(gainNode);
            osc.start();
            osc.stop(audioCtx.currentTime + 0.05);
        }

        let oracleModeUI = false;
        async function toggleOracle() {
            oracleModeUI = !oracleModeUI;
            document.getElementById('oracleBtn').classList.toggle('active');
            await fetch(`/oracle/toggle?enabled=${oracleModeUI}`, { method: 'POST' });
        }
        document.getElementById('oracleBtn').onclick = toggleOracle;

        function updateSound(m) {
            if (!isListening || !audioCtx) return;
            const mode = document.getElementById('audioMode').value;
            const now = audioCtx.currentTime;

            // Main harmonic voices
            if (oscillators.length === 0) {
                // Left channel gain
                const leftG = audioCtx.createGain();
                const rightG = audioCtx.createGain();
                const merger = audioCtx.createChannelMerger(2);

                leftG.connect(merger, 0, 0);
                rightG.connect(merger, 0, 1);
                merger.connect(gainNode);

                for (let i = 1; i <= 6; i++) {
                    const oscL = audioCtx.createOscillator();
                    const oscR = audioCtx.createOscillator();
                    const gL = audioCtx.createGain();
                    const gR = audioCtx.createGain();

                    oscL.type = 'sine';
                    oscR.type = 'sine';

                    oscL.connect(gL); gL.connect(leftG);
                    oscR.connect(gR); gR.connect(rightG);

                    oscL.start(); oscR.start();
                    oscillators.push({ oscL, oscR, gL, gR, h: i });
                }
            }

            const baseF = 180 + (1 - m.mass) * 400;
            const binauralGap = mode === 'binaural' ? 6 : 0; // 6Hz Delta wave gap

            oscillators.forEach(item => {
                const freqL = baseF * item.h;
                const freqR = (baseF + binauralGap) * item.h;

                item.oscL.frequency.setTargetAtTime(freqL, now, 0.1);
                item.oscR.frequency.setTargetAtTime(freqR, now, 0.1);

                const gVal = (item.h <= (m.phase_coherence * 12 + 1)) ? (0.12 / item.h) : 0;
                item.gL.gain.setTargetAtTime(gVal, now, 0.1);
                item.gR.gain.setTargetAtTime(gVal, now, 0.1);
            });

            // Resonance Drone Volume linked to Stability
            const droneVol = mode === 'resonance' ? (m.stability * 0.4) : 0;
            droneGain.gain.setTargetAtTime(droneVol, now, 0.2);

            gainNode.gain.setTargetAtTime(0.2, now, 0.1);
        }

        document.getElementById('audioToggle').onclick = () => {
            initAudio();
            isListening = !isListening;
            const btn = document.getElementById('audioToggle');
            if (isListening) {
                btn.classList.add('active'); btn.innerText = 'üîá SILENCE';
                if (audioCtx.state === 'suspended') audioCtx.resume();
            } else {
                btn.classList.remove('active'); btn.innerText = 'üîä LISTEN';
                gainNode.gain.setTargetAtTime(0, audioCtx.currentTime, 0.1);
            }
        };

        // --- Controls ---
        document.getElementById('startBtn').onclick = () => ws.send('start');
        document.getElementById('resetBtn').onclick = () => { ws.send('reset'); location.reload(); };

        // Export Trajectory Data as CSV (Researcher Feature)
        document.getElementById('exportBtn').onclick = () => {
            if (history.entropy.length === 0) {
                alert('No data to export. Start the reactor first.');
                return;
            }

            let csv = 'timestamp,entropy,mass,phase_coherence,stability,state\n';
            for (let i = 0; i < history.entropy.length; i++) {
                const meanMass = history.mass.slice(0, i + 1).reduce((a, b) => a + b, 0) / (i + 1);
                const entVar = i > 0 ? variance(history.entropy.slice(0, i + 1)) : 0;
                const phaseStd = i > 0 ? std(history.phase.slice(0, i + 1)) : 0.01;
                const stability = (meanMass * (1 - Math.min(0.9, entVar))) / (1 + phaseStd);

                csv += `${i * 0.5},${history.entropy[i]},${history.mass[i]},${history.phase[i]},${stability},${lastState}\n`;
            }

            const blob = new Blob([csv], { type: 'text/csv' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `cer_trajectory_${Date.now()}.csv`;
            a.click();
            URL.revokeObjectURL(url);
        };

        init3D();
        animate3D();

        function applyPreset(p) {
            console.log("Applying preset: " + p);
            const slider = document.getElementById('tempSlider');
            if (p === 'stable') slider.value = 0.5;
            if (p === 'creative') slider.value = 1.0;
            if (p === 'chimera') slider.value = 1.6;
            if (p === 'void') slider.value = 2.0;
            slider.dispatchEvent(new Event('input'));
        }

        document.getElementById('tempSlider').oninput = (e) => {
            const val = e.target.value;
            document.getElementById('temp-val').innerText = val;
            // Future: Send to backend for live temperature modulation
        };


        // Helper to log events
        function logEvent(msg, type = 'info') {
            const log = document.getElementById('event-log');
            if (!log) return;
            const entry = document.createElement('div');
            entry.className = 'log-entry';

            const time = new Date().toLocaleTimeString('en-US', { hour12: false, hour: "2-digit", minute: "2-digit", second: "2-digit" });
            const typeClass = `log-type-${type}`;

            entry.innerHTML = `<span class="log-timestamp">[${time}]</span><span class="${typeClass}">${msg}</span>`;
            log.prepend(entry);

            if (log.children.length > 50) log.removeChild(log.lastChild);
        }



    </script>
</body>

</html>